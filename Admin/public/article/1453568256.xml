<p>PHP默认使用文件来存储session相关数据，而当一个回话中一个PHP页面在对session进行操作时，则此时回话的session文件时被上锁的，因此其他页面必须等该页运行完或主动释放才可对session文件进行操作，因此造成范围的阻塞。</p><p>就如下面这个情况：</p><p>创建session_block_1.php</p><pre class="brush:php;toolbar:false">&lt;?php
session_start();
$_SESSION[&#39;count&#39;]&nbsp;=&nbsp;0;
echo&nbsp;&quot;count&nbsp;=&nbsp;=&quot;.$_SESSION[&#39;count&#39;].&quot;&lt;br&nbsp;/&gt;&quot;;
sleep(10);
echo&nbsp;__FILE__;</pre><p>创建session_block_2.php</p><pre class="brush:php;toolbar:false">&lt;?php
session_start();
$_SESSION[&#39;count&#39;]&nbsp;=&nbsp;1;
echo&nbsp;&quot;count&nbsp;=&nbsp;=&quot;.$_SESSION[&#39;count&#39;].&quot;&lt;br&nbsp;/&gt;&quot;;
echo&nbsp;__FILE__;</pre><p>访问block_1.php然后立即访问block_2.php，会发现只有当差不多在第一个文件返回后第二个文件才会返回（这个差不多是指各种存在各种延时）。</p><p>那怎么破那，来看一下手册的说明：</p><pre class="brush:xml;toolbar:false">Note:
无论是通过调用函数&nbsp;session_start()&nbsp;手动开启会话，&nbsp;还是使用配置项&nbsp;session.auto_start&nbsp;自动开启会话，&nbsp;对于基于文件的会话数据保存（PHP&nbsp;的默认行为）而言，&nbsp;在会话开始的时候都会给会话数据文件加锁，&nbsp;直到&nbsp;PHP&nbsp;脚本执行完毕或者显式调用&nbsp;session_write_close()&nbsp;来保存会话数据。&nbsp;在此期间，其他脚本不可以访问同一个会话数据文件。
对于大量使用&nbsp;Ajax&nbsp;或者并发请求的网站而言，这可能是一个严重的问题。&nbsp;解决这个问题最简单的做法是如果修改了会话中的变量，&nbsp;那么应该尽快调用&nbsp;session_write_close()&nbsp;来保存会话数据并释放文件锁。&nbsp;还有一种选择就是使用支持并发操作的会话保存管理器来替代文件会话保存管理器。</pre><p>So,解决是如此easy：<br/></p><p>对session_block_1.php</p><pre class="brush:php;toolbar:false">&lt;?php
session_start();
$_SESSION[&#39;count&#39;]&nbsp;=&nbsp;0;
//保存会话并释放文件锁
session_write_close();
echo&nbsp;&quot;count&nbsp;=&nbsp;=&quot;.$_SESSION[&#39;count&#39;].&quot;&lt;br&nbsp;/&gt;&quot;;
sleep(10);
echo&nbsp;__FILE__;</pre><p>在重复上面的操作，第二个文件秒开了有没有？（没有，卧槽那是网慢了，服务器宕机了吧）</p><p><br/></p><p>或者通过memcached解决</p>